<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>心情花园</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      overflow: hidden;
      font-family: 'PingFang SC', 'Microsoft YaHei', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    
    #particle-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    
    #welcome-card {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      padding: 50px 80px;
      background: rgba(255, 255, 255, 0.25);
      backdrop-filter: blur(20px) saturate(180%);
      -webkit-backdrop-filter: blur(20px) saturate(180%);
      border-radius: 24px;
      border: 1px solid rgba(255, 255, 255, 0.5);
      box-shadow: 0 20px 60px rgba(144, 238, 144, 0.25), 
                  0 10px 30px rgba(150, 200, 180, 0.2);
      text-align: center;
      z-index: 10;
      animation: fadeIn 1.5s ease-out;
    }
    
    #welcome-card h1 {
      font-size: 32px;
      font-weight: 600;
      letter-spacing: 4px;
      color: #2d4f4d;
      text-shadow: 0 2px 8px rgba(255, 255, 255, 0.8);
    }
    
    #app {
      position: relative;
      z-index: 1;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.9);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }
  </style>
</head>
<body>
  <div id="particle-container"></div>
  <div id="welcome-card">
    <h1>欢迎来到心情花园</h1>
  </div>
  <div id="app"></div>
  <script type="module" src="/src/main.js"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script>
    (function() {
      const container = document.getElementById('particle-container');
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      container.appendChild(renderer.domElement);
      
      camera.position.z = 35;
      
      const gradientCanvas = document.createElement('canvas');
      gradientCanvas.width = 512;
      gradientCanvas.height = 512;
      const ctx = gradientCanvas.getContext('2d');
      const centerX = 256;
      const centerY = 256;
      const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 256);
      gradient.addColorStop(0, '#ffffff');
      gradient.addColorStop(0.3, '#e8f5ec');
      gradient.addColorStop(0.6, '#d0e5d8');
      gradient.addColorStop(1, '#b8d4c2');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      scene.background = new THREE.CanvasTexture(gradientCanvas);
      
      const particleCanvas = document.createElement('canvas');
      particleCanvas.width = 64;
      particleCanvas.height = 64;
      const pctx = particleCanvas.getContext('2d');
      const pgradient = pctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      pgradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
      pgradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');
      pgradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.3)');
      pgradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      pctx.fillStyle = pgradient;
      pctx.fillRect(0, 0, 64, 64);
      
      const particleTexture = new THREE.CanvasTexture(particleCanvas);
      
      const particleCount = 250;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const colors = new Float32Array(particleCount * 3);
      const speeds = new Float32Array(particleCount);
      const amplitudes = new Float32Array(particleCount);
      const phases = new Float32Array(particleCount);
      const originalPositions = new Float32Array(particleCount * 3);
      
      const colorPalette = [
        { r: 0.878, g: 0.949, b: 0.945 },
        { r: 0.698, g: 0.875, b: 0.859 },
        { r: 1.0, g: 1.0, b: 1.0 }
      ];
      
      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;
        positions[i3] = (Math.random() - 0.5) * 80;
        positions[i3 + 1] = (Math.random() - 0.5) * 60;
        positions[i3 + 2] = (Math.random() - 0.5) * 50;
        
        originalPositions[i3] = positions[i3];
        originalPositions[i3 + 1] = positions[i3 + 1];
        originalPositions[i3 + 2] = positions[i3 + 2];
        
        sizes[i] = Math.random() * 1.2 + 0.5;
        
        const color = colorPalette[Math.floor(Math.random() * colorPalette.length)];
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;
        
        speeds[i] = Math.random() * 0.25 + 0.1;
        amplitudes[i] = Math.random() * 0.4 + 0.2;
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 1.0,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        sizeAttenuation: true,
        blending: THREE.AdditiveBlending,
        map: particleTexture,
        depthWrite: false
      });
      
      const particleSystem = new THREE.Points(particles, particleMaterial);
      scene.add(particleSystem);
      
      const glowCount = 3;
      const glows = [];
      const glowColors = [0xd0e5d8, 0xb8d4c2, 0xa5c9b0];
      
      for (let g = 0; g < glowCount; g++) {
        const glowGeometry = new THREE.SphereGeometry(8 + g * 3, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: glowColors[g],
          transparent: true,
          opacity: 0.08
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        glow.position.set(
          (Math.random() - 0.5) * 30,
          (Math.random() - 0.5) * 20,
          (Math.random() - 0.5) * 15 - 10
        );
        glow.userData = {
          speedX: (Math.random() - 0.5) * 0.02,
          speedY: (Math.random() - 0.5) * 0.02,
          speedZ: (Math.random() - 0.5) * 0.02
        };
        scene.add(glow);
        glows.push(glow);
      }
      
      const flowerCount = 20;
      const flowers = [];
      
      function drawFlowerOnCanvas(canvas, color) {
        const ctx = canvas.getContext('2d');
        const centerX = 64;
        const centerY = 64;
        
        ctx.clearRect(0, 0, 128, 128);
        
        for (let i = 0; i < 6; i++) {
          const angle = (i / 6) * Math.PI * 2 - Math.PI / 2;
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(angle);
          
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.quadraticCurveTo(-15, -20, 0, -45);
          ctx.quadraticCurveTo(15, -20, 0, 0);
          ctx.closePath();
          
          const gradient = ctx.createRadialGradient(0, -20, 0, 0, -20, 35);
          gradient.addColorStop(0, '#ffffff');
          gradient.addColorStop(0.3, color);
          gradient.addColorStop(1, 'rgba(255, 182, 193, 0.3)');
          ctx.fillStyle = gradient;
          ctx.fill();
          
          ctx.restore();
        }
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
        const centerGradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 8);
        centerGradient.addColorStop(0, '#fff8dc');
        centerGradient.addColorStop(1, '#ffe4b5');
        ctx.fillStyle = centerGradient;
        ctx.fill();
      }
      
      for (let f = 0; f < flowerCount; f++) {
        const flowerCanvas = document.createElement('canvas');
        flowerCanvas.width = 128;
        flowerCanvas.height = 128;
        
        const flowerColors = ['#ffb6c1', '#ffc0cb', '#ffd1dc', '#ffb7c5'];
        const flowerColor = flowerColors[Math.floor(Math.random() * flowerColors.length)];
        
        drawFlowerOnCanvas(flowerCanvas, flowerColor);
        
        const flowerTexture = new THREE.CanvasTexture(flowerCanvas);
        const flowerGeometry = new THREE.PlaneGeometry(3, 3);
        const flowerMaterial = new THREE.MeshBasicMaterial({
          map: flowerTexture,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide,
          depthWrite: false
        });
        
        const flower = new THREE.Mesh(flowerGeometry, flowerMaterial);
        
        flower.position.set(
          (Math.random() - 0.5) * 60,
          (Math.random() - 0.5) * 45,
          (Math.random() - 0.5) * 30
        );
        
        flower.rotation.x = (Math.random() - 0.5) * Math.PI * 0.5;
        flower.rotation.y = Math.random() * Math.PI * 2;
        
        flower.userData = {
          rotationSpeed: (Math.random() - 0.5) * 0.01,
          floatSpeed: Math.random() * 0.4 + 0.2,
          floatAmplitude: Math.random() * 0.2 + 0.1,
          floatPhase: Math.random() * Math.PI * 2,
          floatSpeedX: (Math.random() - 0.5) * 0.008,
          floatSpeedY: (Math.random() - 0.5) * 0.008
        };
        
        scene.add(flower);
        flowers.push(flower);
      }
      
      let time = 0;
      let mouse = new THREE.Vector2(9999, 9999);
      
      function animate() {
        requestAnimationFrame(animate);
        time += 0.01;
        
        const positionsArray = particleSystem.geometry.attributes.position.array;
        
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          
          let targetX = originalPositions[i3];
          let targetY = originalPositions[i3 + 1];
          
          const particlePos = new THREE.Vector3(positionsArray[i3], positionsArray[i3 + 1], positionsArray[i3 + 2]);
          particlePos.project(camera);
          const screenX = particlePos.x * window.innerWidth / 2 + window.innerWidth / 2;
          const screenY = -particlePos.y * window.innerHeight / 2 + window.innerHeight / 2;
          
          const dx = screenX - mouse.x;
          const dy = screenY - mouse.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const repelRadius = 150;
          
          if (distance < repelRadius) {
            const force = (repelRadius - distance) / repelRadius;
            targetX += (dx / distance) * force * 5;
            targetY += (dy / distance) * force * 5;
          }
          
          positionsArray[i3] = targetX + Math.sin(time * 0.5 + phases[i]) * 0.3;
          positionsArray[i3 + 1] = targetY + Math.sin(time * speeds[i] + phases[i]) * amplitudes[i] + 
                                  (Math.sin(time * 0.3 + i * 0.1) * 0.2);
        }
        
        particleSystem.geometry.attributes.position.needsUpdate = true;
        particleSystem.rotation.y = Math.sin(time * 0.08) * 0.03;
        
        glows.forEach((glow, index) => {
          glow.position.x += glow.userData.speedX;
          glow.position.y += glow.userData.speedY;
          glow.position.z += glow.userData.speedZ;
          
          if (Math.abs(glow.position.x) > 20) glow.userData.speedX *= -1;
          if (Math.abs(glow.position.y) > 15) glow.userData.speedY *= -1;
          if (Math.abs(glow.position.z + 10) > 10) glow.userData.speedZ *= -1;
        });
        
        flowers.forEach(flower => {
          flower.rotation.z += flower.userData.rotationSpeed;
          flower.position.y += Math.sin(time * flower.userData.floatSpeed + flower.userData.floatPhase) * 
                              flower.userData.floatAmplitude * 0.008;
          flower.position.x += flower.userData.floatSpeedX;
          flower.position.y += flower.userData.floatSpeedY;
          flower.rotation.x = (Math.random() - 0.5) * 0.02;
          
          if (Math.abs(flower.position.x) > 35) flower.userData.floatSpeedX *= -1;
          if (Math.abs(flower.position.y) > 25) flower.userData.floatSpeedY *= -1;
        });
        
        renderer.render(scene, camera);
      }
      
      document.addEventListener('mousemove', (event) => {
        mouse.x = event.clientX;
        mouse.y = event.clientY;
      });
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      animate();
    })();
  </script>
</body>
</html>
